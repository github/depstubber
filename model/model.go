// Package model contains the data model necessary for generating stub implementations.
package model

import (
	"bytes"
	"encoding/gob"
	"encoding/json"
	"fmt"
	"go/token"
	"log"
	"os"
	"os/exec"
	"path"
	"reflect"
	"sort"
	"strconv"
	"strings"
	"unicode"
	"unicode/utf8"

	"golang.org/x/mod/semver"
)

// createPackageMap returns a map of import path to package name
// for specified importPaths.
func createPackageMap(importPaths []string) map[string]string {
	var pkg struct {
		Name       string
		ImportPath string
	}
	pkgMap := make(map[string]string)
	b := bytes.NewBuffer(nil)
	args := []string{"list", "-mod=readonly", "-json"}
	args = append(args, importPaths...)
	cmd := exec.Command("go", args...)
	cmd.Stdout = b
	cmd.Run()
	dec := json.NewDecoder(b)
	for dec.More() {
		err := dec.Decode(&pkg)
		if err != nil {
			log.Printf("failed to decode 'go list' output: %v", err)
			continue
		}
		pkgMap[pkg.ImportPath] = pkg.Name
	}
	return pkgMap
}

func isExported(name string) bool {
	r, _ := utf8.DecodeRuneInString(name)
	return r != utf8.RuneError && unicode.IsUpper(r)
}

// pkgPath is the importable path for package model
const pkgPath = "github.com/github/depstubber/model"

type PackedPkg struct {
	Name    string
	PkgPath string
	Body    string
}

func PackPkg(pkg *Package) *PackedPkg {
	return &PackedPkg{
		pkg.Name, pkg.PkgPath, pkg.String(),
	}
}

// Package is a Go package. It may be a subset.
type Package struct {
	Name        string
	PkgPath     string
	UseExtTypes bool
	Exports     map[string]Export
	NamedTypes  map[string]Type
}

func NewPackage(pkgpath string, useExtTypes bool) *Package {
	name := path.Base(pkgpath)

	if semver.IsValid(name) {
		// if the name is a valid semver, use the parent's name
		name = path.Base(path.Dir(pkgpath))
	}

	name = sanitize(name)
	return &Package{
		Name:        name,
		PkgPath:     pkgpath,
		UseExtTypes: useExtTypes,
		Exports:     make(map[string]Export),
		NamedTypes:  make(map[string]Type),
	}
}

func (pkg *Package) String() string {
	var ret string

	// Get all required imports, and generate unique names for them all.
	im := pkg.Imports()

	// Sort keys to make import alias generation predictable
	sortedPaths := make([]string, len(im))
	x := 0
	for pth := range im {
		sortedPaths[x] = pth
		x++
	}
	sort.Strings(sortedPaths)

	packagesName := createPackageMap(sortedPaths)

	pm := make(map[string]string, len(im))
	localNames := make(map[string]bool, len(im))
	for _, pth := range sortedPaths {
		base, ok := packagesName[pth]
		if !ok {
			base = sanitize(path.Base(pth))
		}

		// Local names for an imported package can usually be the basename of the import path.
		// A couple of situations don't permit that, such as duplicate local names
		// (e.g. importing "html/template" and "text/template"), or where the basename is
		// a keyword (e.g. "foo/case").
		// try base0, base1, ...
		pkgName := base
		i := 0
		for localNames[pkgName] || token.Lookup(pkgName).IsKeyword() {
			pkgName = base + strconv.Itoa(i)
			i++
		}

		// Avoid importing package if source pkg == output pkg
		if pth == pkg.PkgPath {
			continue
		}

		pm[pth] = pkgName
		localNames[pkgName] = true
	}

	ret += fmt.Sprintf("// Package %v is a stub of %s, generated by depstubber.\n", pkg.Name, pkg.PkgPath)

	ret += fmt.Sprintf("package %v\n\n", pkg.Name)
	ret += "import (\n"
	for pkgPath, pkgName := range pm {
		if pkgPath == pkg.PkgPath {
			continue
		}
		ret += fmt.Sprintf("\t%v %q\n", pkgName, pkgPath)
	}
	ret += ")\n\n"

	// sort keys so output is deterministic
	keys := make([]string, 0, len(pkg.Exports))
	for key := range pkg.Exports {
		keys = append(keys, key)
	}
	sort.Strings(keys)

	for _, key := range keys {
		export := pkg.Exports[key]

		ret += export.Declaration(pm, pkg.PkgPath) + "\n\n"

		if named, ok := export.(*NamedType); ok {
			// if _, ok := named.Underlying.(*InterfaceType); ok {
			// 	continue
			// }

			// we have a named type that is not an interface, print methods
			for _, meth := range named.Methods {
				ret += meth.Declaration(pm, pkg.PkgPath) + "\n\n"
			}
		}
	}
	return ret
}

// Imports returns the imports needed by the Package as a set of import paths.
func (pkg *Package) Imports() map[string]bool {
	im := make(map[string]bool)
	for _, exp := range pkg.Exports {
		exp.addImports(im)

		if named, ok := exp.(*NamedType); ok {
			for _, meth := range named.Methods {
				meth.addImports(im)
			}

			if intf, ok := named.Underlying.(*InterfaceType); ok {
				for _, meth := range intf.Methods {
					meth.addImports(im)
				}
			}

			if strct, ok := named.Underlying.(*StructType); ok {
				for _, field := range strct.Fields {
					field.Type.addImports(im)
				}
			}
		}
	}

	for _, typ := range pkg.NamedTypes {
		typ.addImports(im)
	}
	return im
}

func (pkg *Package) AddType(name string, typ reflect.Type) error {
	if _, ok := pkg.Exports[name]; ok {
		return nil
	}

	pkg.Exports[name] = nil // ensure that AddType does not run twice

	t, err := pkg.typeFromType(typ)
	if err != nil {
		return err
	}

	switch t := t.(type) {
	case *NamedType:
		pkg.Exports[name] = t
	default:
		fmt.Fprintf(os.Stderr, "Warning: %s resulted in non-exportable type %T\n", name, t)
	}

	return nil
}

func (pkg *Package) AddValue(name string, val reflect.Value) error {
	typ := val.Type()

	t, err := pkg.typeFromType(typ)
	if err != nil {
		return err
	}

	switch t := t.(type) {
	case *FuncType:
		pkg.Exports[name] = &Function{
			Name: name,
			Type: t,
		}
	default:
		pkg.Exports[name] = &Variable{
			Name: name,
			Type: t,
		}
	}

	return nil
}

type Export interface {
	Declaration(pm map[string]string, pkgOverride string) string
	addImports(im map[string]bool)
}

type Variable struct {
	Name string
	Type Type
}

func (v *Variable) Declaration(pm map[string]string, pkgOverride string) string {
	return "var " + v.Name + " " + v.Type.String(pm, pkgOverride) + " = " + zeroOf(v.Type, pm, pkgOverride)
}

func (v *Variable) addImports(im map[string]bool) {
	v.Type.addImports(im)
}

// Function is a function
type Function struct {
	Name string
	Type *FuncType
}

func (f *Function) Declaration(pm map[string]string, pkgOverride string) string {
	args := make([]string, len(f.Type.In))
	for i, p := range f.Type.In {
		args[i] = p.String(pm, pkgOverride)
	}
	if f.Type.Variadic != nil {
		args = append(args, f.Type.Variadic.Name+" ..."+f.Type.Variadic.Type.String(pm, pkgOverride))
	}
	rets := make([]string, len(f.Type.Out))
	for i, p := range f.Type.Out {
		rets[i] = p.Type.String(pm, pkgOverride)
	}
	retString := strings.Join(rets, ", ")
	if nOut := len(f.Type.Out); nOut == 1 {
		retString = " " + retString
	} else if nOut > 1 {
		retString = " (" + retString + ")"
	}
	var retstmt string
	if len(f.Type.Out) > 0 {
		zeros := make([]string, len(f.Type.Out))
		for i, p := range f.Type.Out {
			zeros[i] = zeroOf(p.Type, pm, pkgOverride)
		}
		retstmt = "\n\treturn " + strings.Join(zeros, ", ") + "\n"
	}
	return fmt.Sprintf("func %s(%s) %s {%s}", f.Name, strings.Join(args, ", "), retString, retstmt)
}

func (f *Function) addImports(im map[string]bool) {
	f.Type.addImports(im)
}

// Method is a method
type Method struct {
	Name string
	Type *FuncType
}

// returns the string representation of this method that would be used to declare
// it in an interface declaration
func (m *Method) InterfaceString(pm map[string]string, pkgOverride string) string {
	args := make([]string, 0, len(m.Type.In))
	for _, p := range m.Type.In {
		args = append(args, p.String(pm, pkgOverride))
	}
	if m.Type.Variadic != nil {
		args = append(args, m.Type.Variadic.Name+" ..."+m.Type.Variadic.Type.String(pm, pkgOverride))
	}
	rets := make([]string, len(m.Type.Out))
	for i, p := range m.Type.Out {
		rets[i] = p.Type.String(pm, pkgOverride)
	}
	retString := strings.Join(rets, ", ")
	if nOut := len(m.Type.Out); nOut == 1 {
		retString = " " + retString
	} else if nOut > 1 {
		retString = " (" + retString + ")"
	}
	argStr := fmt.Sprintf("(%s) %s", strings.Join(args, ", "), retString)

	return fmt.Sprintf("%s%s", m.Name, argStr)
}

func (m *Method) Declaration(pm map[string]string, pkgOverride string) string {
	args := make([]string, 0, len(m.Type.In))
	if len(m.Type.In) < 1 {
		fmt.Fprintf(os.Stderr, "Warning: %v has no receiver parameter\n", m)
		return ""
	}
	for _, p := range m.Type.In[1:] {
		args = append(args, p.String(pm, pkgOverride))
	}
	if m.Type.Variadic != nil {
		args = append(args, m.Type.Variadic.Name+" ..."+m.Type.Variadic.Type.String(pm, pkgOverride))
	}
	rets := make([]string, len(m.Type.Out))
	for i, p := range m.Type.Out {
		rets[i] = p.Type.String(pm, pkgOverride)
	}
	retString := strings.Join(rets, ", ")
	if nOut := len(m.Type.Out); nOut == 1 {
		retString = " " + retString
	} else if nOut > 1 {
		retString = " (" + retString + ")"
	}
	argStr := fmt.Sprintf("(%s) %s", strings.Join(args, ", "), retString)

	var retstmt string
	if len(m.Type.Out) > 0 {
		zeros := make([]string, len(m.Type.Out))
		for i, p := range m.Type.Out {
			zeros[i] = zeroOf(p.Type, pm, pkgOverride)
		}
		retstmt = "\n\treturn " + strings.Join(zeros, ", ") + "\n"
	}
	return fmt.Sprintf("func (%s) %s%s {%s}",
		m.Type.In[0].String(pm, pkgOverride), m.Name, argStr, retstmt)
}

func (m *Method) addImports(im map[string]bool) {
	m.Type.addImports(im)
}

// Parameter is an argument or return parameter of a method.
type Parameter struct {
	Name string // may be empty
	Type Type
}

func (p *Parameter) String(pm map[string]string, pkgOverride string) string {
	if p.Type == nil {
		panic("nil parameter type!")
	}

	if p.Name == "" {
		return p.Type.String(pm, pkgOverride)
	}

	return fmt.Sprintf("%s %s", p.Name, p.Type.String(pm, pkgOverride))
}

// Type is a Go type.
type Type interface {
	String(pm map[string]string, pkgOverride string) string
	addImports(im map[string]bool)
}

func init() {
	gob.Register(&PackedPkg{})

	// Call gob.RegisterName to make sure it has the consistent name registered
	// for both gob decoder and encoder.
	//
	// For a non-pointer type, gob.Register will try to get package full path by
	// calling rt.PkgPath() for a name to register. If your project has vendor
	// directory, it is possible that PkgPath will get a path like this:
	//     ../../../vendor/github.com/github/depstubber/model
	gob.RegisterName(pkgPath+".PredeclaredType", PredeclaredType(""))
}

// ArrayType is an array or slice type.
type ArrayType struct {
	Len  int // -1 for slices, >= 0 for arrays
	Type Type
}

func (at *ArrayType) String(pm map[string]string, pkgOverride string) string {
	s := "[]"
	if at.Len > -1 {
		s = fmt.Sprintf("[%d]", at.Len)
	}
	return s + at.Type.String(pm, pkgOverride)
}

func (at *ArrayType) addImports(im map[string]bool) { at.Type.addImports(im) }

// ChanType is a channel type.
type ChanType struct {
	Dir  ChanDir // 0, 1 or 2
	Type Type
}

func (ct *ChanType) String(pm map[string]string, pkgOverride string) string {
	s := ct.Type.String(pm, pkgOverride)
	if ct.Dir == RecvDir {
		return "<-chan " + s
	}
	if ct.Dir == SendDir {
		return "chan<- " + s
	}
	return "chan " + s
}

func (ct *ChanType) addImports(im map[string]bool) { ct.Type.addImports(im) }

// ChanDir is a channel direction.
type ChanDir int

// Constants for channel directions.
const (
	RecvDir ChanDir = 1
	SendDir ChanDir = 2
)

// FuncType is a function type.
type FuncType struct {
	In, Out  []*Parameter
	Variadic *Parameter // may be nil
}

func (ft *FuncType) String(pm map[string]string, pkgOverride string) string {
	args := make([]string, len(ft.In))
	for i, p := range ft.In {
		args[i] = p.Type.String(pm, pkgOverride)
	}
	if ft.Variadic != nil {
		args = append(args, "..."+ft.Variadic.Type.String(pm, pkgOverride))
	}
	rets := make([]string, len(ft.Out))
	for i, p := range ft.Out {
		rets[i] = p.Type.String(pm, pkgOverride)
	}
	retString := strings.Join(rets, ", ")
	if nOut := len(ft.Out); nOut == 1 {
		retString = " " + retString
	} else if nOut > 1 {
		retString = " (" + retString + ")"
	}
	return "func(" + strings.Join(args, ", ") + ")" + retString
}

func (ft *FuncType) addImports(im map[string]bool) {
	for _, p := range ft.In {
		p.Type.addImports(im)
	}
	if ft.Variadic != nil {
		ft.Variadic.Type.addImports(im)
	}
	for _, p := range ft.Out {
		p.Type.addImports(im)
	}
}

// InterfaceType is an interface type.
type InterfaceType struct {
	Methods []*Method
}

var EmptyInterface *InterfaceType = &InterfaceType{nil}

func (it *InterfaceType) Declaration(pm map[string]string, pkgOverride string) string {
	return it.String(pm, pkgOverride)
}

func (it *InterfaceType) String(pm map[string]string, pkgOverride string) string {
	if len(it.Methods) == 0 {
		return "interface{}"
	}
	ret := "interface{\n"
	for _, meth := range it.Methods {
		ret += "\t" + meth.InterfaceString(pm, pkgOverride) + "\n"
	}
	ret += "}"

	return ret
}

func (it *InterfaceType) addImports(im map[string]bool) {
	for _, meth := range it.Methods {
		meth.addImports(im)
	}
}

// MapType is a map type.
type MapType struct {
	Key, Value Type
}

func (mt *MapType) String(pm map[string]string, pkgOverride string) string {
	return "map[" + mt.Key.String(pm, pkgOverride) + "]" + mt.Value.String(pm, pkgOverride)
}

func (mt *MapType) addImports(im map[string]bool) {
	mt.Key.addImports(im)
	mt.Value.addImports(im)
}

// NamedType is an exported type in a package.
type NamedType struct {
	Package    string // may be empty
	Name       string
	Underlying Type

	Methods []*Method
}

func (nt *NamedType) Declaration(pm map[string]string, pkgOverride string) string {
	return "type " + nt.Name + " " + nt.Underlying.String(pm, pkgOverride) + "\n"
}

func (nt *NamedType) String(pm map[string]string, pkgOverride string) string {
	if pkgOverride == nt.Package {
		return nt.Name
	}

	prefix := pm[nt.Package]
	if prefix != "" {
		return prefix + "." + nt.Name
	}

	fmt.Fprintf(os.Stderr, "Warning: import was not found for type %s.%s (package map: %v)\n", nt.Package, nt.Name, pm)

	return nt.Name
}

func (nt *NamedType) addImports(im map[string]bool) {
	if nt.Package != "" {
		im[nt.Package] = true
	}
}

// PointerType is a pointer to another type.
type PointerType struct {
	Type Type
}

func (pt *PointerType) String(pm map[string]string, pkgOverride string) string {
	return "*" + pt.Type.String(pm, pkgOverride)
}
func (pt *PointerType) addImports(im map[string]bool) { pt.Type.addImports(im) }

// PredeclaredType is a predeclared type such as "int".
type PredeclaredType string

func (pt PredeclaredType) String(map[string]string, string) string { return string(pt) }
func (pt PredeclaredType) addImports(map[string]bool)              {}

type Field struct {
	Name string
	Type Type
}

func (f *Field) String(pm map[string]string, pkgOverride string) string {
	return f.Name + " " + f.Type.String(pm, pkgOverride)
}

// StructType is a struct type.
type StructType struct {
	Fields []*Field
}

func (st *StructType) String(pm map[string]string, pkgOverride string) string {
	if len(st.Fields) == 0 {
		return "struct{}"
	}

	ret := "struct{\n"
	for _, field := range st.Fields {
		ret += "\t" + field.String(pm, pkgOverride) + "\n"
	}
	ret += "}"

	return ret
}

func (st *StructType) addImports(im map[string]bool) {
	for _, field := range st.Fields {
		field.Type.addImports(im)
	}
}

// The following code is intended to be called by the program generated by ../reflect.go.

func (pkg *Package) funcArgsFromType(t reflect.Type) (in []*Parameter, variadic *Parameter, out []*Parameter, err error) {
	nin := t.NumIn()
	if t.IsVariadic() {
		nin--
	}
	var p *Parameter
	for i := 0; i < nin; i++ {
		p, err = pkg.parameterFromType(t.In(i))
		if err != nil {
			return
		}
		in = append(in, p)
	}
	if t.IsVariadic() {
		p, err = pkg.parameterFromType(t.In(nin).Elem())
		if err != nil {
			return
		}
		variadic = p
	}
	for i := 0; i < t.NumOut(); i++ {
		p, err = pkg.parameterFromType(t.Out(i))
		if err != nil {
			return
		}
		out = append(out, p)
	}
	return
}

func (pkg *Package) parameterFromType(t reflect.Type) (*Parameter, error) {
	tt, err := pkg.typeFromType(t)
	if err != nil {
		return nil, err
	}
	return &Parameter{Name: "_", Type: tt}, nil
}

var errorType = reflect.TypeOf((*error)(nil)).Elem()

var byteType = reflect.TypeOf(byte(0))

func isInStdlib(pkg string) bool {
	return !strings.ContainsRune(pkg, '.')
}

func (pkg *Package) typeFromType(t reflect.Type) (Type, error) {
	if t == byteType {
		return PredeclaredType("byte"), nil
	}

	if imp := t.PkgPath(); imp != "" {
		if !isExported(t.Name()) || (imp != pkg.PkgPath && !isInStdlib(imp)) {
			return EmptyInterface, nil
		}

		typPath := imp + "." + t.Name()
		if res, ok := pkg.NamedTypes[typPath]; ok {
			return res, nil
		}

		res := &NamedType{
			Package: impPath(imp),
			Name:    t.Name(),
		}

		pkg.NamedTypes[typPath] = res

		if t.Kind() != reflect.Interface {
			seen := make(map[string]bool)

			res.Methods = make([]*Method, 0, t.NumMethod())

			for i := 0; i < t.NumMethod(); i++ {
				mt := t.Method(i)

				if !isExported(mt.Name) {
					continue
				}

				seen[mt.PkgPath+"."+mt.Name] = true

				typ, err := pkg.typeFromType(mt.Type)
				if err != nil {
					return nil, err
				}

				m := &Method{
					Name: mt.Name,
					Type: typ.(*FuncType),
				}

				res.Methods = append(res.Methods, m)
			}

			pt := reflect.PtrTo(t)

			for i := 0; i < pt.NumMethod(); i++ {
				mt := pt.Method(i)

				//fmt.Println(mt.Type.In(0))
				if !isExported(mt.Name) || seen[mt.PkgPath+"."+mt.Name] {
					continue
				}

				typ, err := pkg.typeFromType(mt.Type)
				if err != nil {
					return nil, err
				}

				m := &Method{
					Name: mt.Name,
					Type: typ.(*FuncType),
				}

				res.Methods = append(res.Methods, m)

			}
		}

		var err error
		res.Underlying, err = pkg.unnamedTypeFromType(t)
		if err != nil {
			return nil, err
		}

		if imp == pkg.PkgPath {
			pkg.AddType(t.Name(), t)
		}

		return res, nil
	}

	return pkg.unnamedTypeFromType(t)
}

func (pkg *Package) unnamedTypeFromType(t reflect.Type) (Type, error) {
	if t == byteType {
		return PredeclaredType("byte"), nil
	}

	// Lots of types have element types. Let's do the parsing and error checking for all of them.
	var elemType Type
	switch t.Kind() {
	case reflect.Array, reflect.Chan, reflect.Map, reflect.Ptr, reflect.Slice:
		var err error
		elemType, err = pkg.typeFromType(t.Elem())
		if err != nil {
			return nil, err
		}
	}

	switch t.Kind() {
	case reflect.Array:
		return &ArrayType{
			Len:  t.Len(),
			Type: elemType,
		}, nil
	case reflect.Bool, reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
		reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr,
		reflect.Float32, reflect.Float64, reflect.Complex64, reflect.Complex128, reflect.String:
		return PredeclaredType(t.Kind().String()), nil
	case reflect.Chan:
		var dir ChanDir
		switch t.ChanDir() {
		case reflect.RecvDir:
			dir = RecvDir
		case reflect.SendDir:
			dir = SendDir
		}
		return &ChanType{
			Dir:  dir,
			Type: elemType,
		}, nil
	case reflect.Func:
		in, variadic, out, err := pkg.funcArgsFromType(t)
		if err != nil {
			return nil, err
		}
		return &FuncType{
			In:       in,
			Out:      out,
			Variadic: variadic,
		}, nil
	case reflect.Interface:
		if t == errorType {
			return PredeclaredType("error"), nil
		}

		methods := make([]*Method, 0, t.NumMethod())

		for i := 0; i < t.NumMethod(); i++ {
			mt := t.Method(i)

			if !isExported(mt.Name) {
				continue
			}

			typ, err := pkg.typeFromType(mt.Type)
			if err != nil {
				return nil, err
			}

			m := &Method{
				Name: mt.Name,
				Type: typ.(*FuncType),
			}

			methods = append(methods, m)
		}

		return &InterfaceType{methods}, nil
	case reflect.Map:
		kt, err := pkg.typeFromType(t.Key())
		if err != nil {
			return nil, err
		}
		return &MapType{
			Key:   kt,
			Value: elemType,
		}, nil
	case reflect.Ptr:
		if elemType == EmptyInterface {
			// if the element is the empty interface, we most likely just want it back
			// this is because external types are turned into `interface{}`, but their
			// pointer type does not actually match `*interface{}`
			return EmptyInterface, nil
		}
		return &PointerType{
			Type: elemType,
		}, nil
	case reflect.Slice:
		return &ArrayType{
			Len:  -1,
			Type: elemType,
		}, nil
	case reflect.Struct:
		fields := make([]*Field, 0, t.NumField())

		for i := 0; i < t.NumField(); i++ {
			ft := t.Field(i)

			if !isExported(ft.Name) {
				continue
			}

			typ, err := pkg.typeFromType(ft.Type)
			if err != nil {
				return nil, err
			}

			m := &Field{
				Name: ft.Name,
				Type: typ,
			}

			fields = append(fields, m)
		}

		return &StructType{fields}, nil
	case reflect.UnsafePointer:
		// TODO: generate better types for unsafe pointers
		return EmptyInterface, nil
	}

	return nil, fmt.Errorf("can't yet turn %v (%v) into a model.Type", t, t.Kind())
}

// impPath sanitizes the package path returned by `PkgPath` method of a reflect Type so that
// it is importable. PkgPath might return a path that includes "vendor". These paths do not
// compile, so we need to remove everything up to and including "/vendor/".
// See https://github.com/golang/go/issues/12019.
func impPath(imp string) string {
	if strings.HasPrefix(imp, "vendor/") {
		imp = "/" + imp
	}
	if i := strings.LastIndex(imp, "/vendor/"); i != -1 {
		imp = imp[i+len("/vendor/"):]
	}
	return imp
}

func zeroOf(t Type, pm map[string]string, pkgOverride string) string {
	switch t := t.(type) {
	case *ArrayType, *ChanType, *FuncType, *InterfaceType, *MapType, *PointerType:
		return "nil"
	case *StructType:
		return t.String(pm, pkgOverride) + "{}"
	case *NamedType:
		if _, ok := t.Underlying.(*StructType); ok {
			if pkgOverride == t.Package || t.Package == "" {
				return t.Name + "{}"
			} else {
				return pm[t.Package] + "." + t.Name + "{}"
			}
		}
		return zeroOf(t.Underlying, pm, pkgOverride)
	case PredeclaredType:
		switch t {
		case "bool":
			return "false"
		case "string":
			return `""`
		case "error":
			return "nil"
		default:
			return "0"
		}
	default:
		return ""
	}
}

// sanitize cleans up a string to make a suitable package name.
func sanitize(s string) string {
	t := ""
	for _, r := range s {
		if t == "" {
			if unicode.IsLetter(r) || r == '_' {
				t += string(r)
				continue
			}
		} else {
			if unicode.IsLetter(r) || unicode.IsDigit(r) || r == '_' {
				t += string(r)
				continue
			}
		}
		break
	}
	if t == "_" {
		t = "x"
	}
	return sanitizeKeywords(t)
}

func sanitizeKeywords(name string) string {
	if token.IsKeyword(name) {
		// Package name cannot be a keyword.
		// Add a suffix.
		name += "_pkg"
	}
	return name
}
